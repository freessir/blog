<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>计划任务：crontab 对比 anacron</title>
    <url>//post/crontab-vs-anacron.html</url>
    <content><![CDATA[<p>cron 用于周期性执行定时任务，它的 daemon 叫做 crond，常驻内存。crontab 是用于编辑管理 cron 的指令。同样的，anacron 是指令，anacrontab 是其配置文件。</p>
<p>作为系统服务，cron 可以由 systemctl 管理，能够以分钟精度执行任务。而 anacron 仅是一个指令，需要 cron 调用才能运行。cron 认为主机会 24 小时不间断运行。 anacron 考虑到宕机等实际问题，认为主机不可能不出意外一直连续运行下去，因此会定时执行因意外导致无法被 cron 执行的任务。anacron 可以算是 cron 的补充和完善。</p>
<span id="more"></span>

<p>查看 cron 帮助文档，知道 cron 会检查的文件和目录有：</p>
<ul>
<li>/etc/crontab</li>
<li>/etc/cron.d/</li>
<li>/var/spool/cron/</li>
</ul>
<h2 id="var-spool-cron"><a href="#var-spool-cron" class="headerlink" title="/var/spool/cron/"></a>/var/spool/cron/</h2><p>一般我们使用命令：『crontab -e』来设定定时任务，实际上此命令会在 <code>/var/spool/cron/</code> 目录下创建一个以当前用户为文件名的文件，内容即是 <code>crontab -e</code> 的内容。例如使用 root 用户设置如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0 3 * * * <span class="built_in">echo</span> hello world &gt; /tmp/hello.txt</span><br></pre></td></tr></table></figure>

<p>我们会在 /var/spool/cron/root 文件里看到同样的内容。虽然我们可以直接编辑此文件来设定定时任务，但是还是建议使用 <code>crontab -e</code> 命令，因为 crontab 可以自动判断语法问题。例如：我错误的写成 0 3 * * 少写一个 * 符号，保存退出后会提示错误信息：bad day-of-week。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0 3 * * <span class="built_in">echo</span> hello world &gt; /tmp/hello.txt</span><br><span class="line">crontab: installing new crontab <span class="string">&quot;/tmp/crontab.gCbZsp&quot;</span>:1: bad day-of-week errors <span class="keyword">in</span> crontab file, cant install.Do you want to retry the same edit?</span><br></pre></td></tr></table></figure>

<h2 id="etc-crontab"><a href="#etc-crontab" class="headerlink" title="/etc/crontab"></a>/etc/crontab</h2><p>cron 除了会读取 crontab -e 命令设置的 <code>/var/spool/cron</code> 目录下的文件外，它自己的配置文件：/etc/crontab 也是设定定时任务的地方。跟前面不同的是，配置文件处需要标明执行命令的用户身份。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">01  *  *  *  *   root      run-parts /etc/cron.hourly</span><br></pre></td></tr></table></figure>

<p>上面说的是每小时 01 分以 root 用户身份执行 run-parts /etc/cron.hourly。通过 which 命令查找知道，run-parts 是一个系统定义的用于执行某个目录下所有脚本的 bash 脚本而已。因此当我们写了一个想要定时执行的脚本，可以根据定时执行的频率将脚本丢到对应的 cron 目录去，目录有 cron.hourly、cron.daily、cron.weekly 和 cron.monthly。</p>
<p>但你查看 /etc/crontab 文件，你是看不到上面的定时任务的。因为现在默认不在此处设置定时任务，原因是 anacron 同样会有如上的定时任务命令，避免冲突就给 anacron 设置了。帮助文档说法：</p>
<p><strong>By default  these jobs are now run through anacron which reads /etc/anacrontab configuration file.</strong></p>
<p>也就是说 /etc/crontab 文件就只剩下环境变量的设定，定时任务 “全权” 交由 anacron 管理。</p>
<h2 id="etc-cron-d"><a href="#etc-cron-d" class="headerlink" title="/etc/cron.d/"></a>/etc/cron.d/</h2><p>一直藏着不见的 anacron 就是在这里被 cron 调用的。cron 除了会读取上面两个文件外，还会读取这个目录下的所有文件。其中有个名为 0hourly 的文件内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Run the hourly jobs</span></span><br><span class="line">SHELL=/bin/bash</span><br><span class="line">PATH=/sbin:/bin:/usr/sbin:/usr/bin</span><br><span class="line">MAILTO=root</span><br><span class="line">01 * * * * root run-parts /etc/cron.hourly</span><br></pre></td></tr></table></figure>

<p>可以看到定义了每小时使用 root 身份使用 run-parts 命令运行 /etc/cron.hourly 目录下的所有脚本。然后前往 /etc/cron.hourly 目录，发现有且只有一个 0anacron 文件，内容最后一行分明写着：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/usr/sbin/anacron -s</span><br></pre></td></tr></table></figure>

<p>cron 就是这样调用 anacron 的，而anacron 的配置文件 /etc/anacrontab 就可以明确找到对  cron.daily、cron.weekly 和 cron.monthly  四个目录的定时任务命令了。没有 cron.hourly 是因为 anacron 的精度只到 “天” 级别。另外 /etc/cron.d/ 通过放置 0hourly 文件来间接调用 cron.hourly，也没丢掉 “小时” 级别精度下的控制。</p>
<p>查阅 anacrontab 的帮助文档，下面的原文大意是：如果想要禁用 anacron，将 0anacron 文件移动到 /etc/cron.hourly/jobs.deny 目录下。</p>
<p> <strong>In case you want to disable Anacron, add the 0anacron cron job (which is a part of crontab(1)) into the /etc/cron.hourly/jobs.deny directory.</strong></p>
<p>这样也反向证明了 cron 的确是通过读取 /etc/cron.d/0hourly 调用 /etc/cron.hourly/0anacron 脚本来运行 anacron 的。</p>
<h2 id="anacron"><a href="#anacron" class="headerlink" title="anacron"></a>anacron</h2><p>crontab 配置文件内的定时任务交给 anacron 管理后，anacron 会到点儿执行任务，并在执行完成后将当前时间精确到 “天” 记录到 /var/spool/anacron/ 对应的文件里，标记这次执行成功的时间。等到下次执行任务时，首先对比上次执行成功的时间，再决定是否执行。</p>
<p>例如：在 3 月 10 号因为意外导致主机宕机，原定每天凌晨 1:00 的任务没有执行，那么 anacron 记录的任务成功执行的时间是在 3 月 9 日。因为 anacron 是通过 cron 的 cron.hourly 以 ”小时” 为精度被调用的，假设主机在凌晨 2:00 恢复运行，那么 cron 会在 2:01 调用 anacron，anacron 读取记录知道上次执行任务是在 3 月 9 日，需要再次执行任务。所以 anacron 可以在任何时间执行未执行的任务。</p>
<p>anacron 在执行任务过程中，如果有信息输出，默认会邮件给执行 anacron 的用户；如果指定了变量 MAILTO，那么会优先发送给他。日志信息会记录在 cron 里，级别为 notice。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">SHELL=/bin/sh</span><br><span class="line">PATH=/sbin:/bin:/usr/sbin:/usr/bin</span><br><span class="line">MAILTO=root</span><br><span class="line"><span class="comment"># the maximal random delay added to the base delay of the jobs</span></span><br><span class="line">RANDOM_DELAY=45</span><br><span class="line"><span class="comment"># the jobs will be started during the following hours only</span></span><br><span class="line">START_HOURS_RANGE=3-22</span><br><span class="line"></span><br><span class="line"><span class="comment">#period in days   delay in minutes   job-identifier   command</span></span><br><span class="line">1	5	cron.daily		nice run-parts /etc/cron.daily</span><br><span class="line">7	25	cron.weekly		nice run-parts /etc/cron.weekly</span><br><span class="line">@monthly 45	cron.monthly		nice run-parts /etc/cron.monthly</span><br></pre></td></tr></table></figure>

<p>anacrontab 的定时任务格式跟 crontab 很像。第一个数字表示执行任务的间隔，单位天，第一个数字表示延迟时间，单位分钟。设置延迟是为了避免所有任务都在同一时间执行造成拥堵，因此在此基础上增加了变量 RANDOM_DELAY，最大随机延迟。</p>
<p>​</p>
]]></content>
      <categories>
        <category>linux study</category>
      </categories>
  </entry>
  <entry>
    <title>iptables 使用学习</title>
    <url>//post/iptables-use-study.html</url>
    <content><![CDATA[<p>Linux 防火墙分为 应用层防火墙 和 包过滤防火墙，iptables 属于包过滤防火墙，底层使用的是 Linux 内核模块 netfilter，性能佳稳定性好。</p>
<h2 id="原理简析"><a href="#原理简析" class="headerlink" title="原理简析"></a>原理简析</h2><p>iptables 基本结构：</p>
<blockquote>
<p>iptables -&gt; 规则表 -&gt; 规则链 -&gt; 具体规则</p>
</blockquote>
<span id="more"></span>

<p>可以看出 iptables 通过参数 t 指定要操作的规则表，使用命令（如添加、删除、替换、清空、查看等）控制规则链，再指定规则的条件，最后使用参数 j 控制数据包的行为。</p>
<p>iptables 用的最多的是 filter 表和 nat 表。filter 表用于数据过滤，nat 表用于网络地址转换。</p>
<p>filter 表有 INPUT、OUTPUT 和 FORWARD 等规则链。INPUT 链控制数据包的流入，PUTPUT 链控制数据包的流出，FORWARD 链控制数据的转发。</p>
<p>nat 表有 PREROUTING、POSTROUTING 和 OUTPUT 规则链，PREROUTING 链用来修改数据包的目标端口和地址，POSTROUTING 链用来修改数据的源端口和地址，OUTPUT 链作用类似 PREROUTING 链，不过是用来修改本机发出的数据的 目标端口和地址。</p>
<p>这几个规则链的关系如下：</p>
<img src="/post/iptables-use-study/iptables_01.gif" class="" title="流量在 iptables 链的流动途径">

<p>当外面的数据包进入本机，首先会经过 PREROUTING 链，对修改后的目标地址进行路由判断，如果发现其目标就是本机，那就走 A 经过 INPUT 链的筛选，符合条件就放行至本应用处理；如果发现目标地址是其他主机，那就走 B 使用 FORWARD 链进行转发，最后通过 POSTROOUTING 链出去。POSTROUTING 链很重要的工作是修改来源地址为本机，并记录这个修改关系。数据回传的时候本机通过这个修改关系转发数据给源主机。</p>
<p>当本机要发出数据包，先经过路由判断进入 nat 表的 OUTPUT 链，用来修改目标主机，然后经过 filter 表的 OUTPUT 链的筛选，符合条件就放行到 POSTROUTING 链，修改源地址就包并发出。</p>
<p>用来修改目标地址的 PREROUTING 链必须放在最前面，放在路由后面将无法选择 A 还是 B。POSTROUTING 链必须放在最后，等到所有链判断完成后再修改源地址，如果放在前面，倘若数据包都出不来，提前修改源地址纯属浪费力气。所以这这个链的位置是有讲究的，并不是随意放置。</p>
<h2 id="语法命令"><a href="#语法命令" class="headerlink" title="语法命令"></a>语法命令</h2><p>iptables 语法格式：</p>
<blockquote>
<p>iptables [-t 表名] 命令选项 [链名] [条件匹配] [-j 目标动作或跳转]</p>
</blockquote>
<h3 id="命令选项"><a href="#命令选项" class="headerlink" title="命令选项"></a>命令选项</h3><p>iptables 常用的命令选项：</p>
<ul>
<li>-A：–append，在规则链的尾部插入规则</li>
<li>-I： –insert，默认在规则链的头部插入规则，可以指定位置</li>
<li>-D：删除规则链中指定规则</li>
<li>-F：清空指定链的规则。不指定则清空所有链</li>
<li>-L：–list，查看指定链的规则。不指定则显示所有链</li>
<li>-v：查看规则时显示详细信息</li>
<li>-n：不将 ip 地址反解析为域名</li>
</ul>
<h3 id="条件匹配"><a href="#条件匹配" class="headerlink" title="条件匹配"></a>条件匹配</h3><p>条件匹配分为基本匹配和扩展匹配，扩展匹配又可以分为隐式扩展匹配和显式扩展匹配。基本匹配命令：</p>
<ul>
<li>-p：指定协议规则，tcp、ip 和 icmp</li>
<li>-s：指定数据包的源地址</li>
<li>-d：指定数据包的目标地址</li>
<li>-i ：指定入站流量的网卡</li>
<li>-o：指定出站流量的网卡</li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p><strong>放行 80 端口</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -t filter -I INPUT --dport 80 -j ACCEPT</span><br></pre></td></tr></table></figure>

<p>iptables 默认操作 filter 表，因此可以省略；INPUT 表示流量流入，方向是客户机到本机，所以客户机 ip 是源 ip，放行的本地端口就是目标端口；可以增加参数 i 指定网卡，增加参数 s 指定客户机 ip。</p>
<p><strong>允许来自 10.0.0.1 流量通过 80 端口</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -s 10.0.0.1 -i eth0 -p tcp --dport 80 -j ACCEPT</span><br></pre></td></tr></table></figure>

<p>上面使用了参数 p，表示指定协议为 tcp。</p>
<p><strong>查看规则</strong></p>
<p>只要没有语法问题，设置了规则后 iptables 默认没有任何提示。当我们想要查看规则，可以使用命令 L 查看。结合参数 vn 就可以显示更为现实的规则信息并只显示 ip。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables --line-numbers -vnL</span><br></pre></td></tr></table></figure>

<p>上面使用参数 –line-numbers 可以显示每条规则的编号，便于定位。</p>
<p>一般网上使用命令 iptables -F 来清空 iptables，认为 iptables 太复杂，直接清空不要防火墙了。虽然 -F 参数有清空的作用，但是情况前需要格外注意默认的规则。当我们使用 -vnL 显示规则时，在第一行会看到如下类似信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Chain INPUT (policy REJECT 285 packets, 48260 bytes)</span><br></pre></td></tr></table></figure>
<p>上面表示 input 规则链的默认 policy 是 reject，这种情况下你胆敢 -F 清空 iptables，你就惊奇发现：怎么动不了了？</p>
<p>使用 -P 参数更改默认 policy 为 accept，再清空。或者直接卸载 iptables。。。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -P INPUT ACCEPT</span><br><span class="line">iptables -P OUTPUT ACCEPT</span><br></pre></td></tr></table></figure>

<p><strong>高级模块</strong></p>
<p>再看看比较高级的模块。如果想要限制连接数量，使用 –connlimit，例如只允许最多 5 个用户使用 ssh 连接主机：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -p tcp --dport 22 -m connlimit --connlimit-above 5 -j DROP</span><br></pre></td></tr></table></figure>
<p>使用 –limit 来限制连接频率，例如限制 ping 速度。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -p icmp -m <span class="built_in">limit</span> --<span class="built_in">limit</span> 10/s --limit-burst 12 -j ACCEPT</span><br></pre></td></tr></table></figure>

<p>不过我测试 limit 好像限制不了 icmp，听说就是这样？</p>
<p>除了 limit，还可以使用 recent 模块。recent 涉及到地址列表，首先使用 –set 参数将连接到本机的 源ip 加入到地址列表里，将地址列表取名为 restricted-ping。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -m --<span class="built_in">set</span> --name restricted-ping</span><br></pre></td></tr></table></figure>

<p>因为目的还没有达到，就不用 -j 指定操作。然后使用参数 name 指定上面的地址列表，使用 –seconds 参数指定时间，使用 –hitcount 指定次数，来实现频率限制。例如在半个小时内只允许 10 个用户连接 ssh。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -p tcp --dport 22 -m recet --rcheck --seconds 1800 --hitcount 10</span><br><span class="line">--name restricted-ping -j ACCEPT</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux study</category>
      </categories>
      <tags>
        <tag>iptables</tag>
      </tags>
  </entry>
</search>
